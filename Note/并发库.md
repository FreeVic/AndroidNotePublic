#Java并发库分享

##前言
2004年下半年，Sun公司发布了开发代号为“Tiger”的J2SE 5.0，直接从1.4跳到5.0，这次里程碑的改变带来了泛型、元数据、增强型循环、并发工具包、监控和管理、RMI编辑器等新特性。而今天我们主要聊下其中的并发工具包。
这篇分享的目的：

> 1.帮助大家更好的利用jdk特性处理并发问题
> 2.给大家整理下线程方面的知识点

[TOC]

###什么是并发
并发多个事件在同一时间执行，并行多个事件在同一时刻执行，下面这张图就比较清晰
![enter image description here](http://7xqdxj.com1.z0.glb.clouddn.com/concurrency0.jpeg)
说起并发，必然会想到两个东西：**线程Thread**和**共享数据SharedData**，再向下联想就会有线程安全（同步互斥）、线程通信、线程范围内的数据共享等概念

####开启线程
- **传统方式**
（暂且称5.0之前为传统，之后为现在）开启线程：
> 1.Thread匿名内部类
> 2.Runnable实现类
> 3.Timer和TimerTask（如果细究也可以作为开线程的一种方式）

- **现在**：
> 1.Callable接口实现类（异步方法可以有返回值）
> 2.Executors的各种线程池操作
> 


###并发库：

> java.util.concurrent  
> java.util.concurrent.atmoic
> java.util.concurrent.lock

####lock包

1. **ReentrantLock**

 需求:多个线程调用一个对象的方法，保证安全

- 传统：<span id="b1"></span>[Test1](#1)
- 现在：<span id="b3"></span>[Test3](#3)

2. **ReentrantLock、Condition**

 需求：子线程打印10下，主线程打印100下，子线程再打印10下，主线程再打印100下，以此循环往复50次

- 传统：<span id="b2"></span>[Test2](#2)
- 现在：<span id="b4"></span>[Test4](#4)
 如果改成三个线程的交替执行呢？
那么传统方式实现就会比较麻烦，而现在的方式还是这样的 <span id="b18"></span>[Test18](#18)

3. **ReentrantReadWriteLock**
读写锁例子 <span id="b5"></span>[Test5](#5)
官方文档里ReentrantReadWriteLock实现的缓存 <span id="b19"></span>[Test19](#19)
####atomic包
主要有以下类
![enter image description here](http://7xqdxj.com1.z0.glb.clouddn.com/Atomic.jpeg)
由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。以AtomicInteger、AtomicReference为例，修改方法基本都是线程安全的。其他类不再赘述 <span id="b21"></span>[Test21](#21)
####concurrent包
这个包中有非常多好用的类，以下用大量篇幅进行介绍

1. **Executors**
这个类相信大家都不陌生，各种线程池管理，各种好用
![enter image description here](http://7xqdxj.com1.z0.glb.clouddn.com/Executors.jpeg)
然而我们使用最多也最应该关心的还是红圈内的几组方法 Test6：
> newCachedThreadPool 缓存的线程池 
> newFixedThreadPool 固定数量的线程池
> newScheduledThreadPool 调度管理的线程池  
> newScheduledThreadPool  单线程池

 既然大家经常会用到这个类，那么问题来了：

 - CachedThreadPool和FixedThreadPool有什么区别？
 - newScheduledThreadPool(1)和newScheduledThreadPool 有什么区别？
 
2. **Semaphore**

 类似控制当前访问自身线程个数的信号灯，并提供了同步机制 acquire（阻塞）/release  <span id="b7"></span>[Test7](#7)
> 官方文档：Acquires a permit from this semaphore, blocking until one is
> available, or the thread is interrupted. Acquires a permit, if one is
> available and returns immediately, reducing the number of available
> permits by one.

3. **CyclicBarrier**
类似跟团旅游，只有在所有人都集合完毕之后，才出发去下一个景区 await(阻塞) <span id="b8"></span>[Test8](#8)
> 官方文档：Waits until all parties have invoked await on this barrier.
> 
> If the current thread is not the last to arrive then it is disabled
> for thread scheduling purposes and lies dormant until one of the
> following things happens:
> - The last thread arrives; 
> - or Some other thread interrupts the current thread; 
> - or Some other thread interrupts one of the other waiting threads; 
>- or Some other thread invokes reset() on this barrier.

4. **CountDownLatch**
类似倒计时计数器，只有当计数到0的时候事件才会被触发。例如赛场上只有运动员都通过终点之后，也就是正在赛场上的运动员数量为0时，裁判才会安排下一场比赛 <span id="b9"></span>[Test9](#9)
> 官方文档：Causes the current thread to wait until the latch has counted down to
> zero, unless the thread is interrupted. If the current count is zero
> then this method returns immediately.
> 
> If the current count is greater than zero then the current thread
> becomes disabled for thread scheduling purposes and lies dormant until
> one of two things happen:
> 
> - The count reaches zero due to invocations of the countDown() method;
> - or Some other thread interrupts the current thread. 
> 
> If the current thread:
> 
> - has its interrupted status set on entry to this method; 
> - or isinterrupted while waiting, 
> 
> then InterruptedException is thrown and the urrent thread's interrupted status is cleared.

5. **Exchanger**
类似两个人交换数据，先完成的会一直阻塞等待交换数据 <span id="b10"></span>[Test10](#10)

6. **Callable、Future、CompletionService**
Callable、Future和CompletionService配合使用，具有返回值的异步任务线程池 <span id="b14"></span>[Test14](#14)

7. **ArrayBlockingQueue**
线程安全的同步队列，注意其中的三组存取方法的使用场景,如下图，分别会抛出异常、返回具体值、阻塞、超时 <span id="b17"></span>[Test17](#17)
![enter image description here](http://7xqdxj.com1.z0.glb.clouddn.com/blockingqueue.jpeg)

8. **SynchronousQueue**
类似同步队列，但是如果没有取(或存)的操作，那么存(或取)的操作就会阻塞

9. **CopyOnWriteArrayList**
类似可以并发修改的ArrayList集合，遍历过程当中同样可以进行修改(添加删除等)操作，适合于遍历的数量大大超过可变操作的数量，效率更高,相关的集合类还有 ConcurrentHashMap,ConcurrentLinkedDeque,ConcurrentLinkedQueue,ConcurrentSkipListSet, CopyOnWriteArraySet等 <span id="b13"></span>[Test13](#13)

> 唉，人老了就喜欢多扯一点，最后再啰嗦一下线程范围内的数据共享，当然，这个不是5.0的新东西，直接上图


![enter image description here](http://7xqdxj.com1.z0.glb.clouddn.com/threadlocal.jpeg)

- 如果我们自己去实现：<span id="b15"></span>[Test15](#15)
- ThreadLocal做法：<span id="b16"></span>[Test16](#16)

###问题
1. 传统（java1.5之前）开启线程的方式？
2. 能否在run方法上抛出InterruptedException，以便省略sleep 的try／catch？
3. Thread内部类设置了Runnable，内部类和Runnable的run方法哪个会执行，为什么？
4. 两个线程不停打印字符串的例子，保证安全
5. 子线程打印10下，主线程打印100下，子线程再打印10下，主线程再打印100下，以此循环往复50次
6. 第5题中如果是三个线程之间的切换要如何做？
7. 3个面试问题
    - 第一题read
     现有的程序代码模拟产生了16个日志对象，并且需要运行16秒才能打印完这些日志，请在程序中增加4个线程去调用parseLog()方法来分头打印这16个日志对象，程序只需要运行4秒即可打印完这些日志对象。原始代码如下：
     
		  public class Test1 {
	    
	        public static void main(String[] args) {
	    
	            System.out.println("begin:" + (System.currentTimeMillis() / 1000));
	                /*模拟处理16行日志，下面的代码产生了16个日志对象，当前代码需要运行16秒才能打印完这些日志。
	                修改程序代码，开四个线程让这16个对象在4秒钟打完。
	                */
	            for (int i = 0; i < 16; i++) {  //这行代码不能改动
	                final String log = "" + (i + 1);//这行代码不能改动
	                {
	                    Test1.parseLog(log);
	                }
	            }
	        }
	    
	        //parseLog方法内部的代码不能改动
	        public static void parseLog(String log) {
	            System.out.println(log + ":" + (System.currentTimeMillis() / 1000));
	    
	            try {
	                Thread.sleep(1000);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	        }
	    
	    }
    - 第二题queue
    现成程序中的Test类中的代码在不断地产生数据，然后交给TestDo.doSome()方法去处理，就好像生产者在不断地产生数据，消费者在不断消费数据。请将程序改造成有10个线程来消费生成者产生的数据，这些消费者都调用TestDo.doSome()方法去进行处理，故每个消费者都需要一秒才能处理完，程序应保证这些消费者线程依次有序地消费数据，只有上一个消费者消费完后，下一个消费者才能消费数据，下一个消费者是谁都可以，但要保证这些消费者线程拿到的数据是有顺序的。原始代码如下：

	    public class Test2 {
	    
	        public static void main(String[] args) {
	    
	            System.out.println("begin:" + (System.currentTimeMillis() / 1000));
	            for (int i = 0; i < 10; i++) {  //这行不能改动
	                String input = i + "";  //这行不能改动
	                String output = TestDo.doSome(input);
	                System.out.println(Thread.currentThread().getName() + ":" + output);
	            }
	        }
	    }
	    
	    //不能改动此TestDo类
	    class TestDo {
	        public static String doSome(String input) {
	    
	            try {
	                Thread.sleep(1000);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	            String output = input + ":" + (System.currentTimeMillis() / 1000);
	            return output;
	        }
	    }
    - 第三题syn
    现有程序同时启动了4个线程去调用TestDo.doSome(key, value)方法，由于TestDo.doSome(key, value)方法内的代码是先暂停1秒，
 然后再输出以秒为单位的当前时间值，所以，会打印出4个相同的时间值，如下所示：
        4:4:1258199615
        1:1:1258199615
        3:3:1258199615
        1:2:1258199615
        请修改代码，如果有几个线程调用TestDo.doSome(key, value)方法时，
 传递进去的key相等（equals比较为true），则这几个线程应互斥排队输出结果，即当有两个线程的key都是"1"时，
 它们中的一个要比另外其他线程晚1秒输出结果，如下所示：
        4:4:1258199615
        1:1:1258199615
        3:3:1258199615
        1:2:1258199616
        总之，当每个线程中指定的key相等时，这些相等key的线程应每隔一秒依次输出时间值（要用互斥），
 如果key不同，则并行执行（相互之间不互斥）。原始代码如下：

	    //不能改动此Test类
	    public class Test3 extends Thread {
	    
	        private TestDo3 testDo3;
	        private String key;
	        private String value;
	    
	        public Test3(String key, String key2, String value) {
	            this.testDo3 = TestDo3.getInstance();
	                /*常量"1"和"1"是同一个对象，下面这行代码就是要用"1"+""的方式产生新的对象，
	                以实现内容没有改变，仍然相等（都还为"1"），但对象却不再是同一个的效果*/
	            this.key = key + key2;
	            this.value = value;
	        }
	    
	    
	        public static void main(String[] args) throws InterruptedException {
	            Test3 a = new Test3("1", "", "1");
	            Test3 b = new Test3("1", "", "2");
	            Test3 c = new Test3("3", "", "3");
	            Test3 d = new Test3("4", "", "4");
	            System.out.println("begin:" + (System.currentTimeMillis() / 1000));
	            a.start();
	            b.start();
	            c.start();
	            d.start();
	    
	        }
	    
	        public void run() {
	            testDo3.doSome(key, value);
	        }
	    }
	    
	    class TestDo3 {
	    
	        private TestDo3() {
	        }
	    
	        private static TestDo3 _instance = new TestDo3();
	    
	        public static TestDo3 getInstance() {
	            return _instance;
	        }
	    
	        public void doSome(Object key, String value) {
	    
	            // 以大括号内的是需要局部同步的代码，不能改动!
	            {
	                try {
	                    Thread.sleep(1000);
	                    System.out.println(key + ":" + value + ":"
	                            + (System.currentTimeMillis() / 1000));
	                } catch (InterruptedException e) {
	                    e.printStackTrace();
	                }
	            }
	        }
	    
	    }
###关于答案

> 源码里com.workec.answer包下

###源码
<span id="1">Test1</span> [返回](#b1)

    package com.workec.test;
    
    /**
     * 传统方式同步互斥
     * synchronized关键字
     */
    public class Test1 {
    
        public static void main(String[] args) {
            new Test1().init();
        }
    
        private void init() {
            final Outputer outputer = new Outputer();
            new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true) {
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        outputer.output1("suhuiyong");
                    }
    
                }
            }).start();
    
            new Thread(new Runnable() {
                @Override
                public void run() {
                    while (true) {
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        outputer.output3("wujianwen");
                    }
    
                }
            }).start();
    
        }
    
        static class Outputer {
    
            public void output0(String name) {
                int len = name.length();
                for (int i = 0; i < len; i++) {
                    System.out.print(name.charAt(i));
                }
                System.out.println();
            }
    
            public void output1(String name) {
                int len = name.length();
                synchronized (Outputer.class) {
                    for (int i = 0; i < len; i++) {
                        System.out.print(name.charAt(i));
                    }
                    System.out.println();
                }
            }
    
            public synchronized void output2(String name) {
                int len = name.length();
                for (int i = 0; i < len; i++) {
                    System.out.print(name.charAt(i));
                }
                System.out.println();
            }
    
            public static synchronized void output3(String name) {
                int len = name.length();
                for (int i = 0; i < len; i++) {
                    System.out.print(name.charAt(i));
                }
                System.out.println();
            }
        }
    
    }

<span id="2">Test2</span> [返回](#b2)

    package com.workec.test;
    
    /**
     * 传统方式线程通信
     * 线程交替打印
     */
    public class Test2 {
    
        /**
         * @param args
         */
        public static void main(String[] args) {
            
            final Business business = new Business();
            new Thread(
                    new Runnable() {
                        
                        @Override
                        public void run() {
                        
                            for(int i=1;i<=50;i++){
                                business.sub(i);
                            }
                            
                        }
                    }
            ).start();
            
            for(int i=1;i<=50;i++){
                business.main(i);
            }
            
        }
    
    }
      class Business {
          private boolean bShouldSub = true;
          public synchronized void sub(int i){
              while(!bShouldSub){
                  try {
                    this.wait();
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
              }
                for(int j=1;j<=10;j++){
                    System.out.println("sub thread sequence of " + j + ",loop of " + i);
                }
              bShouldSub = false;
              this.notify();
          }
          
          public synchronized void main(int i){
                  while(bShouldSub){
                      try {
                        this.wait();
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                  }
                for(int j=1;j<=100;j++){
                    System.out.println("main thread sequence of " + j + ",loop of " + i);
                }
                bShouldSub = true;
                this.notify();
          }
      }

<span id="3">Test3</span> [返回](#b3)

    package com.workec.test;
    
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    
    /**
     * 现在方式Lock
     */
    public class Test3 {
    
        /**
         * @param args
         */
        public static void main(String[] args) {
            new Test3().init();
        }
        
        private void init(){
            final Outputer outputer = new Outputer();
            new Thread(new Runnable(){
                @Override
                public void run() {
                    while(true){
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        outputer.output("suhuiyong");
                    }
                    
                }
            }).start();
            
            new Thread(new Runnable(){
                @Override
                public void run() {
                    while(true){
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        outputer.output3("wujianwen");
                    }
                    
                }
            }).start();
            
        }
    
        static class Outputer{
            static Lock lock = new ReentrantLock();
            public void output(String name){
                int len = name.length();
                lock.lock();
                try{
                    for(int i=0;i<len;i++){
                        System.out.print(name.charAt(i));
                    }
                    System.out.println();
                }finally{
                    lock.unlock();
                }
            }
            
            public synchronized void output2(String name){
                int len = name.length();
                for(int i=0;i<len;i++){
                        System.out.print(name.charAt(i));
                }
                System.out.println();
            }
            
            public static synchronized void output3(String name){
    			lock.lock();
                int len = name.length();
                for(int i=0;i<len;i++){
                        System.out.print(name.charAt(i));
                }
                System.out.println();
    			lock.unlock();
            }    
        }
    }

<span id="4">Test4</span> [返回](#b4)

    package com.workec.test;
    
    import java.util.concurrent.atomic.AtomicInteger;
    import java.util.concurrent.locks.Condition;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    public class Test4 {
    
        /**
         * @param args
         */
        public static void main(String[] args) {
            
            final Business business = new Business();
            new Thread(
                    new Runnable() {
                        
                        @Override
                        public void run() {
                        
                            for(int i=1;i<=50;i++){
                                business.sub(i);
                            }
                            
                        }
                    }
            ).start();
            
            for(int i=1;i<=50;i++){
                business.main(i);
            }
            
        }
    
        static class Business {
                Lock lock = new ReentrantLock();
                Condition condition = lock.newCondition();
              private boolean bShouldSub = true;
              public  void sub(int i){
                  lock.lock();
                  try{
                      while(!bShouldSub){
                          try {
                            condition.await();
                        } catch (Exception e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                      }
                        for(int j=1;j<=10;j++){
                            System.out.println("sub thread sequence of " + j + ",loop of " + i);
                        }
                      bShouldSub = false;
                      condition.signal();
                  }finally{
                      lock.unlock();
                  }
              }
              
              public  void main(int i){
                  lock.lock();
                  try{
                     while(bShouldSub){
                              try {
                                condition.await();
                            } catch (Exception e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                            }
                          }
                        for(int j=1;j<=100;j++){
                            System.out.println("main thread sequence of " + j + ",loop of " + i);
                        }
                        bShouldSub = true;
                        condition.signal();
              }finally{
                  lock.unlock();
              }
          }
        
        }
    }

<span id="5">Test5</span>  [返回](#b5)

    package com.workec.test;
    
    import java.util.Random;
    import java.util.concurrent.locks.ReadWriteLock;
    import java.util.concurrent.locks.ReentrantReadWriteLock;
    
    /**
     * 现在方式  读写锁
     */
    public class Test5 {
        public static void main(String[] args) {
            final Queue3 q3 = new Queue3();
            for(int i=0;i<3;i++)
            {
                new Thread(){
                    public void run(){
                        while(true){
                            q3.get();                        
                        }
                    }
                    
                }.start();
    
                new Thread(){
                    public void run(){
                        while(true){
                            q3.put(new Random().nextInt(10000));
                        }
                    }            
                    
                }.start();
            }
            
        }
    }
    
    class Queue3{
        private Object data = null;
        ReadWriteLock rwl = new ReentrantReadWriteLock();
        public void get(){
            rwl.readLock().lock();
            try {
                System.out.println(Thread.currentThread().getName() + " be ready to read data!");
                Thread.sleep((long)(Math.random()*1000));
                System.out.println(Thread.currentThread().getName() + "have read data :" + data);            
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally{
                rwl.readLock().unlock();
            }
        }
        
        public void put(Object data){
    
            rwl.writeLock().lock();
            try {
                System.out.println(Thread.currentThread().getName() + " be ready to write data!");                    
                Thread.sleep((long)(Math.random()*1000));
                this.data = data;        
                System.out.println(Thread.currentThread().getName() + " have write data: " + data);                    
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally{
                rwl.writeLock().unlock();
            }
            
        
        }
    }

<span id="6">Test6</span> [返回](#b6)

    package com.workec.test;
    
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    import java.util.concurrent.TimeUnit;
    
    public class Test6 {
    
        /**
         * @param args
         */
        public static void main(String[] args) {
            //ExecutorService threadPool = Executors.newFixedThreadPool(3);
            //ExecutorService threadPool = Executors.newCachedThreadPool();
            ExecutorService threadPool = Executors.newSingleThreadExecutor();
            for(int i=1;i<=10;i++){
                final int task = i;
                threadPool.execute(new Runnable(){
                    @Override
                    public void run() {
                        for(int j=1;j<=10;j++){
                            try {
                                Thread.sleep(20);
                            } catch (InterruptedException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                            }
                            System.out.println(Thread.currentThread().getName() + " is looping of " + j + " for  task of " + task);
                        }
                    }
                });
            }
            System.out.println("all of 10 tasks have committed! ");
            //threadPool.shutdownNow();
            
            Executors.newScheduledThreadPool(3).scheduleAtFixedRate(
                    new Runnable(){
                        @Override
                    public void run() {
                        System.out.println("bombing!");
                        
                    }},
                    6,
                    2,
                    TimeUnit.SECONDS);
        }
    
    }

<span id="7">Test7</span> [返回](#b7)

    package com.workec.test;
    
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    import java.util.concurrent.Semaphore;
    
    /**
     *  Semaphore 测试
     */
    public class Test7 {public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        final  Semaphore sp = new Semaphore(3);
        for(int i=0;i<10;i++){
            Runnable runnable = new Runnable(){
                public void run(){
                    try {
                        sp.acquire();
                    } catch (InterruptedException e1) {
                        e1.printStackTrace();
                    }
                    System.out.println("线程" + Thread.currentThread().getName() +
                            "进入，当前已有" + (3-sp.availablePermits()) + "个并发");
                    try {
                        Thread.sleep((long)(Math.random()*10000));
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("线程" + Thread.currentThread().getName() +
                            "即将离开");
                    sp.release();
                    System.out.println("线程" + Thread.currentThread().getName() +
                            "已离开，当前已有" + (3-sp.availablePermits()) + "个并发");
                }
            };
            service.execute(runnable);
        }
    }
    
    }

<span id="8">Test8</span> [返回](#b8)

    package com.workec.test;
    import java.util.concurrent.CyclicBarrier;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    
    /**
     * CyclicBarrier 测试 
     * 
     */
    public class Test8 {
    
        public static void main(String[] args) {
            ExecutorService service = Executors.newCachedThreadPool();
            final  CyclicBarrier cb = new CyclicBarrier(3);
            for(int i=0;i<3;i++){
                Runnable runnable = new Runnable(){
                    public void run(){
                        try {
                            Thread.sleep((long)(Math.random()*10000));
                            System.out.println("线程" + Thread.currentThread().getName() +
                                    "即将到达集合地点1，当前已有" + (cb.getNumberWaiting()+1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊A":"正在等候"));
                            cb.await();
    
                            Thread.sleep((long)(Math.random()*10000));
                            System.out.println("线程" + Thread.currentThread().getName() +
                                    "即将到达集合地点2，当前已有" + (cb.getNumberWaiting()+1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊B":"正在等候"));
                            cb.await();
                            Thread.sleep((long)(Math.random()*10000));
                            System.out.println("线程" + Thread.currentThread().getName() +
                                    "即将到达集合地点3，当前已有" + (cb.getNumberWaiting() + 1) + "个已经到达，" + (cb.getNumberWaiting()==2?"都到齐了，继续走啊C":"正在等候"));
                            cb.await();
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                };
                service.execute(runnable);
            }
            service.shutdown();
        }
    }

<span id="9">Test9</span> [返回](#b9)

        package com.workec.test;
        import java.util.concurrent.CountDownLatch;
        import java.util.concurrent.CyclicBarrier;
        import java.util.concurrent.ExecutorService;
        import java.util.concurrent.Executors;
        
        /**
         * CountdownLatch 测试
         */
        public class Test9 {
        
            public static void main(String[] args) {
                ExecutorService service = Executors.newCachedThreadPool();
                final CountDownLatch cdOrder = new CountDownLatch(1);
                final CountDownLatch cdAnswer = new CountDownLatch(3);
                for(int i=0;i<3;i++){
                    Runnable runnable = new Runnable(){
                        public void run(){
                            try {
                                System.out.println("线程" + Thread.currentThread().getName() +
                                        "正准备接受命令");
                                cdOrder.await();
                                System.out.println("线程" + Thread.currentThread().getName() +
                                        "已接受命令");
                                Thread.sleep((long)(Math.random()*10000));
                                System.out.println("线程" + Thread.currentThread().getName() +
                                        "回应命令处理结果");
                                cdAnswer.countDown();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                    };
                    service.execute(runnable);
                }
                try {
                    Thread.sleep((long)(Math.random()*10000));
        
                    System.out.println("线程" + Thread.currentThread().getName() +
                            "即将发布命令");
                    cdOrder.countDown();
                    System.out.println("线程" + Thread.currentThread().getName() +
                            "已发送命令，正在等待结果");
                    cdAnswer.await();
                    System.out.println("线程" + Thread.currentThread().getName() +
                            "已收到所有响应结果");
                } catch (Exception e) {
                    e.printStackTrace();
                }
                service.shutdown();
        
            }
        }
    
    <span id="10">Test10</span> [返回](#b10)
    package com.workec.test;
    import java.util.concurrent.Exchanger;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    
    public class Test10 {
    
        public static void main(String[] args) {
            ExecutorService service = Executors.newCachedThreadPool();
            final Exchanger exchanger = new Exchanger();
            service.execute(new Runnable(){
                public void run() {
                    try {
    
                        String data1 = "suhuiyong";
                        System.out.println("线程" + Thread.currentThread().getName() +
                                "正在把数据" + data1 +"换出去");
                        Thread.sleep((long)(Math.random()*10000));
                        String data2 = (String)exchanger.exchange(data1);
                        System.out.println("线程" + Thread.currentThread().getName() +
                                "换回的数据为" + data2);
                    }catch(Exception e){
    
                    }
                }
            });
            service.execute(new Runnable(){
                public void run() {
                    try {
    
                        String data1 = "wujianwen";
                        System.out.println("线程" + Thread.currentThread().getName() +
                                "正在把数据" + data1 +"换出去");
                        Thread.sleep((long)(Math.random()*10000));
                        String data2 = (String)exchanger.exchange(data1);
                        System.out.println("线程" + Thread.currentThread().getName() +
                                "换回的数据为" + data2);
                    }catch(Exception e){
    
                    }
                }
            });
        }
    }
<span id="11">Test11</span> [返回](#b11)

    package com.workec.test;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.BlockingQueue;
    
    public class Test11 {
        public static void main(String[] args) {
            final BlockingQueue queue = new ArrayBlockingQueue(3);
            for(int i=0;i<2;i++){
                new Thread(){
                    public void run(){
                        while(true){
                            try {
                                Thread.sleep((long)(Math.random()*1000));
                                System.out.println(Thread.currentThread().getName() + "准备放数据!");
    //                            queue.add(1);
    //                            queue.put(1);
                                queue.offer(1);
                                System.out.println(Thread.currentThread().getName() + "已经放了数据，" +
                                        "队列目前有" + queue.size() + "个数据");
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
    
                        }
                    }
    
                }.start();
            }
    
            new Thread(){
                public void run(){
                    while(true){
                        try {
                            //将此处的睡眠时间分别改为100和1000，观察运行结果
                            Thread.sleep(1000);
                            System.out.println(Thread.currentThread().getName() + "准备取数据!");
    //                        queue.remove();
    //                        queue.take();
                            queue.poll();
                            System.out.println(Thread.currentThread().getName() + "已经取走数据，" +
                                    "队列目前有" + queue.size() + "个数据");
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
    
            }.start();
        }
    }
<span id="13">Test13</span> [返回](#b13)

    package com.workec.test;
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.Iterator;
    import java.util.concurrent.CopyOnWriteArrayList;
    public class Test13 {
        public static void main(String[] args) {
            new Test13().m2();
        }
    
        private void m0(){
            ArrayList<User> users = new ArrayList<User>();
            users.add(new User("苏会勇",28));
            users.add(new User("王冠英",25));
            users.add(new User("巫瑜通",31));
            users.add(new User("吴剑文",15));
            for (int i = 0; i < 10; i++) {
                users.add(new User("苏会勇",28));
            }
    
            users.add(new User("蔡明鹏",16));
            users.add(new User("蔚志坚",17));
            int size = users.size();
    //        for (int i = 0; i < users.size(); i++) {
    //            System.out.println("aaaa");
    //            User user = users.get(i);
    //            if("苏会勇".equals(user.getName())){
    //                users.remove(user);
    //            } else {
    //                System.out.println(user);
    //            }
    //        }
    
            for(int i= users.size()-1;i>=0;i--){
                System.out.println("aaaa");
                User user = users.get(i);
                if("苏会勇".equals(user.getName())){
                    users.remove(user);
                } else {
                    System.out.println(user);
                }
            }
    //        for(User user:users){
    //            System.out.println("aaaa");
    //            if("苏会勇".equals(user.getName())){
    //                users.remove(user);
    //                users.add(new User("Tricker",14));
    //            } else {
    //                System.out.println(user);
    //            }
    //        }
        }
    
        private void m1(){
            Collection users = new ArrayList<User>();
            users.add(new User("苏会勇",28));
            users.add(new User("王冠英",25));
            users.add(new User("巫瑜通",31));
    		users.add(new User("吴剑文",15));
    		users.add(new User("蔡明鹏",16));
            users.add(new User("蔚志坚",17));
            Iterator itrUsers = users.iterator();
            while(itrUsers.hasNext()){
                System.out.println("aaaa");
                User user = (User)itrUsers.next();
                if("巫瑜通".equals(user.getName())){
                    users.remove(user);
                    //itrUsers.remove();
                } else {
                    System.out.println(user);
                }
            }
        }
        private void m2(){
            Collection users = new CopyOnWriteArrayList<User>();
            users.add(new User("苏会勇",28));
            users.add(new User("王冠英",25));
            users.add(new User("巫瑜通",31));
            users.add(new User("吴剑文",15));
            users.add(new User("蔡明鹏",16));
            users.add(new User("蔚志坚",17));
            Iterator itrUsers = users.iterator();
            while(itrUsers.hasNext()){
                System.out.println("aaaa");
                User user = (User)itrUsers.next();
                if("巫瑜通".equals(user.getName())){
                    users.remove(user);
                    //itrUsers.remove();
                } else {
                    System.out.println(user);
                }
            }
        }
    
    }     
   <span id="14">Test14</span> [返回](#b14)
 

      package com.workec.test;
    
    import java.util.Random;
    import java.util.concurrent.Callable;
    import java.util.concurrent.CompletionService;
    import java.util.concurrent.ExecutionException;
    import java.util.concurrent.ExecutorCompletionService;
    import java.util.concurrent.ExecutorService;
    import java.util.concurrent.Executors;
    import java.util.concurrent.Future;
    import java.util.concurrent.TimeUnit;
    
    
    /**
     * Callable和Future/CompletionService
     */
    public class Test14 {
    
        /**
         * @param args
         */
        public static void main(String[] args) {
            ExecutorService threadPool =  Executors.newSingleThreadExecutor();
            Future<String> future =
                    threadPool.submit(
                            new Callable<String>() {
                                public String call() throws Exception {
                                    Thread.sleep(2000);
                                    return "hello";
                                };
                            }
                    );
            System.out.println("等待结果");
            try {
                System.out.println("拿到结果：" + future.get());
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
    
            ExecutorService threadPool2 =  Executors.newFixedThreadPool(10);
            CompletionService<Integer> completionService = new ExecutorCompletionService<Integer>(threadPool2);
            for(int i=1;i<=10;i++){
                final int seq = i;
                completionService.submit(new Callable<Integer>() {
                            @Override
                            public Integer call() throws Exception {
                                Thread.sleep(new Random().nextInt(5000));
                                return seq;
                    }
                });
            }
            for(int i=0;i<10;i++){
                try {
                    System.out.println(
                            completionService.take().get());
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    }
<span id="15">Test15</span> [返回](#b15)

    package com.workec.test;
    
    import java.util.HashMap;
    import java.util.Map;
    import java.util.Random;
    
    /**
     * 自己实现
     * 线程范围内的共享数据
     */
    public class Test15 {
    
        private static int data = 0;
        private static Map<Thread, Integer> threadData = new HashMap<Thread, Integer>();
        public static void main(String[] args) {
            for(int i=0;i<2;i++){
                new Thread(new Runnable(){
                    @Override
                    public void run() {
                        int data = new Random().nextInt();
                        System.out.println(Thread.currentThread().getName() 
                                + " has put data :" + data);
                        threadData.put(Thread.currentThread(), data);
                        new A().get();
                        new B().get();
                    }
                }).start();
            }
        }
        
        static class A{
            public void get(){
                int data = threadData.get(Thread.currentThread());
                System.out.println("A from " + Thread.currentThread().getName() 
                        + " get data :" + data);
            }
        }
        
        static class B{
            public void get(){
                int data = threadData.get(Thread.currentThread());            
                System.out.println("B from " + Thread.currentThread().getName() 
                        + " get data :" + data);
            }        
        }
    }

<span id="16">Test16</span> [返回](#b16)

    package com.workec.test;
    
    import java.util.Random;
    
    public class Test16 {
    
        private static ThreadLocal<Integer> x = new ThreadLocal<Integer>();
        private static ThreadLocal<MyThreadScopeData> myThreadScopeData = new ThreadLocal<MyThreadScopeData>();
        public static void main(String[] args) {
            for(int i=0;i<2;i++){
                new Thread(new Runnable(){
                    @Override
                    public void run() {
                        int data = new Random().nextInt();
                        System.out.println(Thread.currentThread().getName() 
                                + " has put data :" + data);
                        x.set(data);
    /*                    MyThreadScopeData myData = new MyThreadScopeData();
                        myData.setName("name" + data);
                        myData.setAge(data);
                        myThreadScopeData.set(myData);*/
                        MyThreadScopeData.getThreadInstance().setName("name" + data);
                        MyThreadScopeData.getThreadInstance().setAge(data);
                        new A().get();
                        new B().get();
                    }
                }).start();
            }
        }
        
        static class A{
            public void get(){
                int data = x.get();
                System.out.println("A from " + Thread.currentThread().getName() 
                        + " get data :" + data);
    /*            MyThreadScopeData myData = myThreadScopeData.get();;
                System.out.println("A from " + Thread.currentThread().getName() 
                        + " getMyData: " + myData.getName() + "," +
                        myData.getAge());*/
                MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();
                System.out.println("A from " + Thread.currentThread().getName() 
                        + " getMyData: " + myData.getName() + "," +
                        myData.getAge());
            }
        }
        
        static class B{
            public void get(){
                int data = x.get();            
                System.out.println("B from " + Thread.currentThread().getName() 
                        + " get data :" + data);
                MyThreadScopeData myData = MyThreadScopeData.getThreadInstance();
                System.out.println("B from " + Thread.currentThread().getName() 
                        + " getMyData: " + myData.getName() + "," +
                        myData.getAge());            
            }        
        }
    }
    
    class MyThreadScopeData{
        private MyThreadScopeData(){}
        public static /*synchronized*/ MyThreadScopeData getThreadInstance(){
            MyThreadScopeData instance = map.get();
            if(instance == null){
                instance = new MyThreadScopeData();
                map.set(instance);
            }
            return instance;
        }
        //private static MyThreadScopeData instance = null;//new MyThreadScopeData();
        private static ThreadLocal<MyThreadScopeData> map = new ThreadLocal<MyThreadScopeData>();
        
        private String name;
        private int age;
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
    }

<span id="17">Test17</span> [返回](#b17)

    package com.workec.test;
    
    import java.util.Collections;
    import java.util.concurrent.ArrayBlockingQueue;
    import java.util.concurrent.BlockingQueue;
    import java.util.concurrent.atomic.AtomicInteger;
    
    public class Test17 {
    
        /**
         * @param args
         */
        public static void main(String[] args) {
            
            final Business business = new Business();
            new Thread(
                    new Runnable() {
                        
                        @Override
                        public void run() {
                        
                            for(int i=1;i<=50;i++){
                                business.sub(i);
                            }
                            
                        }
                    }
            ).start();
            
            for(int i=1;i<=50;i++){
                business.main(i);
            }
            
        }
    
         static class Business {
             
             
              BlockingQueue<Integer> queue1 = new ArrayBlockingQueue<Integer>(1);
              BlockingQueue<Integer> queue2 = new ArrayBlockingQueue<Integer>(1);
              
              {
                  try {
                      System.out.println("xxxxxdfsdsafdsa");
                    queue2.put(1);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
              }
              
              public  void sub(int i){
                      try {
                        queue1.put(1);
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    for(int j=1;j<=10;j++){
                        System.out.println("sub thread sequece of " + j + ",loop of " + i);
                    }
                    try {
                        queue2.take();
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
              }
              
              public  void main(int i){
                      try {
                        queue2.put(1);
                    } catch (InterruptedException e1) {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                    }
                    for(int j=1;j<=100;j++){
                        System.out.println("main thread sequece of " + j + ",loop of " + i);
                    }
                    try {
                        queue1.take();
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
              }
          }
    
    }

<span id="18">Test18</span> [返回](#b18)

    package com.workec.test;
    
    import java.util.concurrent.atomic.AtomicInteger;
    import java.util.concurrent.locks.Condition;
    import java.util.concurrent.locks.Lock;
    import java.util.concurrent.locks.ReentrantLock;
    
    /**
     * 现在方式 进程通信Lock
     */
    public class Test18 {
    
        /**
         * @param args
         */
        public static void main(String[] args) {
            
            final Business business = new Business();
            new Thread(
                    new Runnable() {
                        
                        @Override
                        public void run() {
                        
                            for(int i=1;i<=50;i++){
                                business.sub2(i);
                            }
                            
                        }
                    }
            ).start();
            
            new Thread(
                    new Runnable() {
                        
                        @Override
                        public void run() {
                        
                            for(int i=1;i<=50;i++){
                                business.sub3(i);
                            }
                            
                        }
                    }
            ).start();        
            
            for(int i=1;i<=50;i++){
                business.main(i);
            }
            
        }
    
        static class Business {
                Lock lock = new ReentrantLock();
                Condition condition1 = lock.newCondition();
                Condition condition2 = lock.newCondition();
                Condition condition3 = lock.newCondition();
              private int shouldSub = 1;
              public  void sub2(int i){
                  lock.lock();
                  try{
                      while(shouldSub != 2){
                          try {
                            condition2.await();
                        } catch (Exception e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                      }
                        for(int j=1;j<=10;j++){
                            System.out.println("sub2 thread sequence of " + j + ",loop of " + i);
                        }
                      shouldSub = 3;
                      condition3.signal();
                  }finally{
                      lock.unlock();
                  }
              }
    
              public  void sub3(int i){
                  lock.lock();
                  try{
                      while(shouldSub != 3){
                          try {
                            condition3.await();
                        } catch (Exception e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                      }
                        for(int j=1;j<=20;j++){
                            System.out.println("sub3 thread sequence of " + j + ",loop of " + i);
                        }
                      shouldSub = 1;
                      condition1.signal();
                  }finally{
                      lock.unlock();
                  }
              }          
              
              public  void main(int i){
                  lock.lock();
                  try{
                     while(shouldSub != 1){
                              try {
                                condition1.await();
                            } catch (Exception e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                            }
                          }
                        for(int j=1;j<=100;j++){
                            System.out.println("main thread sequence of " + j + ",loop of " + i);
                        }
                        shouldSub = 2;
                        condition2.signal();
              }finally{
                  lock.unlock();
              }
          }
        
        }
    }

<span id="19">Test19</span> [返回](#b19)

    package com.workec.test;
    
    import java.util.HashMap;
    import java.util.Map;
    import java.util.concurrent.locks.ReadWriteLock;
    import java.util.concurrent.locks.ReentrantReadWriteLock;
    
    /**
     *  读写锁 缓存实现
     */
    public class Test19 {
    
        private Map<String, Object> cache = new HashMap<String, Object>();
        public static void main(String[] args) {
            // TODO Auto-generated method stub
    
        }
    
        private ReadWriteLock rwl = new ReentrantReadWriteLock();
        public  Object getData(String key){
            rwl.readLock().lock();
            Object value = null;
            try{
                value = cache.get(key);
                if(value == null){
                    rwl.readLock().unlock();
                    rwl.writeLock().lock();
                    try{
                        if(value==null){
                            value = "aaaa";//实际是去queryDB();
                        }
                    }finally{
                        rwl.writeLock().unlock();
                    }
                    rwl.readLock().lock();
                }
            }finally{
                rwl.readLock().unlock();
            }
            return value;
        }
    }

<span id="20">Test20</span> [返回](#b20)

    package com.workec.test;
    
    import java.util.Date;
    import java.util.Timer;
    import java.util.TimerTask;
    
    /**
     * Timer和TimerTask
     */
    public class Test20 {
    
        private static int count = 0;
        public static void main(String[] args) {
    /*        new Timer().schedule(new TimerTask() {
                
                @Override
                public void run() {
                    System.out.println("bombing!");
                    
                }
            }, 10000,3000);*/
            
    
            class MyTimerTask extends TimerTask{
                
                @Override
                public void run() {
                    count = (count+1)%2;
                    System.out.println("bombing!");
                    new Timer().schedule(/*new TimerTask() {
                        
                        @Override
                        public void run() {
                            System.out.println("bombing!");
                        }
                    }*/new MyTimerTask(),2000+2000*count);
                }
            }
            
            new Timer().schedule(new MyTimerTask(), 2000);
            
            while(true){
                System.out.println(new Date().getSeconds());
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        }
    
    }
<span id="21">Test21</span> [返回](#b21)

    package com.workec.test;
    
    import java.util.concurrent.atomic.AtomicInteger;
    import java.util.concurrent.atomic.AtomicReference;
    
    /**
     * Atmoic
     */
    public class Test21 {
        public void main(String[] args){
    
        }
    
        class Counter {
            private volatile int count = 0;
    
            public synchronized void increment() {
                count++;  //若要线程安全执行执行count++，需要加锁
            }
    
            public int getCount() {
                return count;
            }
        }
    
        class AtomicCounter {
            private AtomicInteger count = new AtomicInteger();
    
            public void increment() {
                count.incrementAndGet();
            }
            //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。
            public int getCount() {
                return count.get();
            }
        }
    
        class AtomicRefer{
            private AtomicReference<User> reference = new AtomicReference<User>();
            public void setReference(User user){
                reference.set(user);
            }
    
            public AtomicReference<User> getReference() {
                return reference;
            }
        }
    }

